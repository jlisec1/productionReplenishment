import requests
from urllib.parse import urljoin
import csv
from config import config
import psycopg2
import numpy as np

# must have config.py and part_qty_config.csv saved in directory  
# Set authentication and server parameters
# Refer here for auth servers and api endpoints: https://manual.firstresonance.io/api/access-tokens
API_URL = 'https://api.ion-gov.com'
AUTHENTICATION_SERVER = 'auth.ion-gov.com'

CREATE_KIT_MUTATION = '''
    mutation createPartKit($input: CreatePartKitInput!) {
        createPartKit(input: $input) {
            partKit {
                id
            }
        }
    }
'''

CREATE_KIT_ITEM_MUTATION = '''
    mutation createPartKitItem($input: CreatePartKitItemInput!) {
        createPartKitItem(input: $input) {
            partKitItem {
                id
            }
        }
    }
'''
conn = psycopg2.connect(
    database="postgres", user="epirussystems_com_readonly", password="2q&9RudZM5KZ",
    host="ionproduction-read-replica.ckoxzigzezdn.us-gov-west-1.rds.amazonaws.com", port="5432"
)

conn.autocommit = True

cursor = conn.cursor()

cursor.execute(
    "select parts.id,  locations.name, parts_inventory.quantity as inventory_qty from epirussystems_com.parts join epirussystems_com.parts_inventory on parts.id = parts_inventory.part_id join epirussystems_com.locations on parts_inventory.location_id = locations.id")

resul = cursor.fetchall();

conn.close()
results = np.array(resul)
keys = ['part_id', 'location_id', 'quantity']
current_inventory = [dict(zip(keys, l)) for l in results]


def get_access_token():
    """Get accesss token to use in API calls."""
    payload = {
        'grant_type': 'client_credentials',
        'client_id': config['CLIENT_ID'],
        'client_secret': config['CLIENT_SECRET'],
        'audience': API_URL
    }

    headers = {'content-type': 'application/x-www-form-urlencoded'}

    auth_url = urljoin(f'https://{AUTHENTICATION_SERVER}', '/auth/realms/api-keys/protocol/openid-connect/token',
                       'oauth/token')
    res = requests.post(auth_url, data=payload, headers=headers)
    if res.status_code != 200:
        raise RuntimeError('An error occurred in the API request')
    return res.json()['access_token']


def get_csv_data():
    """Import csv data from file."""
    csv_data = []
    with open('part_qty_config.csv', newline='') as f:
        reader = csv.reader(f, delimiter=',', quotechar='"')
        columns = []
        for row_number, row in enumerate(reader):
            row_object = {}
            if row_number == 0:
                columns = row
                continue
            for index, value in enumerate(row):
                row_object[columns[index]] = value
            csv_data.append(row_object)
    return csv_data


def call_api(query, variables, access_token):
    """Calls ions GraphQL api."""
    headers = {
        'Authorization': f'{access_token}',
        'Content-Type': 'application/json'
    }
    print(variables)
    res = requests.post(urljoin(API_URL, 'graphql'),
                        headers=headers,
                        json={'query': query, 'variables': variables})
    if res.status_code != 200:
        print(res.text)
        raise RuntimeError('An error occurred in the API request')
    return res.json()['data']


def create_part_kit(access_token):
    """Create part kits by calling API."""
    print('creating kit')
    kit_payload = {
        'assignedToId': 373
    }

    part_kit = call_api(CREATE_KIT_MUTATION, {'input':kit_payload}, access_token)
    part_kit_id = part_kit['createPartKit']['partKit']['id']
    print(f"Created part kit: {part_kit_id}")
    return part_kit_id

def create_part_kit_item(access_token, part_kit_id, part_id, request_quantity):
    print(part_kit_id)
    kit_item_payload = {
        'partKitId': part_kit_id,
        'partId': part_id,
        'quantity': request_quantity
    }
    call_api(CREATE_KIT_ITEM_MUTATION, {'input': kit_item_payload}, access_token)
    print(f"Added part_id {part_id} to {part_kit_id}")

def get_current_inventory():
    """Gets the current inventory level based on json above.

    This should be replaced with a query."""
    current_inventory_dict = {}
    for item in current_inventory:
        current_inventory_dict[(item['part_id'], item['location_id'])] = item['quantity']
    return current_inventory_dict


def check_inventory_levels(access_token, inventory_config, current_inventory_dict):
    """Checks inventory level vs desired min/max for part/location."""
    part_kit_id = None
    for part in inventory_config:  # inventory config
        print(part)
        part_id = part['part_id']
        location_id = part['location_id']
        inventory_qty = current_inventory_dict.get((int(part_id), int(location_id)), 0)
        if inventory_qty < float(part['min_qty']):
            request_quantity = float(part['max_qty']) - inventory_qty
            if part_kit_id is None:
                part_kit_id = create_part_kit(access_token)
            create_part_kit_item(access_token, part_kit_id, part_id, request_quantity)

def check_inventory_levels_part(access_token, inventory_config, current_inventory_dict, part_kit_id):
    for part in inventory_config:  # inventory config
        print(part)
        part_id = part['part_id']
        location_id = part['location_id']
        inventory_qty = current_inventory_dict.get((int(part_id), int(location_id)), 0)
        if inventory_qty < float(part['min_qty']):
            request_quantity = float(part['max_qty']) - inventory_qty
            create_part_kit_item(access_token,part_kit_id, part_id, location_id, request_quantity)

part_kit_id = None
access_token = get_access_token()
inventory_config = get_csv_data()
current_inventory_dict = get_current_inventory()
check_inventory_levels(access_token, inventory_config, current_inventory_dict)

